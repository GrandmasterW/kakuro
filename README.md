# kakuro

A simple solver for Kakuro games (https://en.wikipedia.org/wiki/Kakuro), written in Clojure. 

This program only provides a terminal mode, no GUI. 

## Installation
### Steps
* Install a modern JDK, for fast computation you might want to use GraalVM
* Install Clojure
* Install leiningen
* Clone repo from github
* lein run my-puzzle-file > output.html

### Tech stack at the time of writing
* OS: Mac OS X 10.15.7 - Catalina
* Java: OpenJDK 14.0.1 or Java SE 12.0.2 / GraalVM CE 20.2.0 (for faster results)
* Clojure: 1.10.1
* lein: Leiningen 2.9.5 on Java 12.0.2 Java HotSpot(TM) 64-Bit Server VM

## Usage
### Running
Basically, you can use the uberjar in target/uberjar, generated by 'lein uberjar'. Then call java like so: 

    $ java -jar <name of standalone jar file here> [args]

#### Args 

name of input file

#### Output

A HTML file containing the definition and results, you might want to redirect it into a file. 

Hint: The CSS-file t.css is located in resources/. The generated HTML assumes it to be in same directory as itself. You might want to copy or link the file to your output directory. 

### How to create a puzzle to solve

You can construct a puzzle to be solved like the ones in the data directory. You will have to provide: 

#### Segments for rows and columns
Each segment needs to have: from-a, to-a, b, sum. 

For a row, from-a is the smaller x value, to-a the larger x value, b is y value, for columns the other way. Sum is the constraint.

* Row example: [3 5 3 12] defines a segment from x=3 to 5 (3 cells) in row 3 with sum 12
* Column example: [1 3 1 9] defines a segment from y=1 to 3 (4 cells) in column 1 with sum 9

When reading the definition, the program will check if the number of cells defined by rows and by columns matches. If not, you'll be informed by an exception. 

#### Solutions
Solutions are optional - just for testing. 

The structure is an EDN file: 

* Hash-map with keys
* :rows -> vector of row segments
* :columns -> vector of column segments
* :solutions -> vector of strings, each defining a solution. <- can be copied from html output.

## Solution strategy

The algorithm tries to emulate a human player: 

### Reduce cell values in each segment with patterns
First try to reduce the potential value sets per cell as much as possible. 

* Therefore, we restrict the values to the sets given by patterns: 17 in 2 results in value set #{8 9}. 
* Secondly, we restrict by using the open sum of the segment. 
* We iterate as long as there is a change in the results. This covers the change effects from considering the rows first, then the column segments. 
	  
### Reduce to valid combinations in each segment 
Next we filter out invalid combinations for the open cells in a segment. 

Example: If the rest-sum of a segment is 8 in 2 open cells, we can reduce the value sets: 

* Result from pattern restriction step could be: #{1 2 3 4 5 6 7} and #{1 3 4 5}
* Cell A: #{3 7}
* Cell B: #{1 5}

This part makes use of Clojure combinatorics library. 

Again, we iterate this step for rows and columns as long as we see changes in the result. 

### Iterate over values of a cell

Now that we have reduced the value sets of the open cells as much as possible, only strategy left is to iterate over one cells value set: we simply evaluate each variation. 

For each value in the set we then re-enter (by Clojure recursion) the steps above. 

### Conclusion

The reduce-as-much-as-possible strategy has proven to be quite fast. At least much faster than my initial attempts... Which is why I inserted a limit into the iteration steps, see util.clj. 

Solution of an 8 by 8 Kakuro puzzle of level "master" (whatever that means) on my machine (example run): 

Using Graal VM (see above)
iMac (Retina 5K, 27 Zoll, 2019), 3.7 GHz 6-Core Intel Core i5 with 8 GB

Steps: 69928
Solutions: 1
Elapsed time: 35730.57888 msecs

## Options

None

## Examples


Check directory data for Kakuro puzzle examples. See doc directory for a spreadsheet with a simple example. 


## To Do 
### Testcases

* Extend test cases, starting with automated solving of provided examples and comparing results
* Compute a set of non-trivial Kakuro puzzles and solve them as tests.
* Extend test cases

### Clean-up
* Remove Segment record structure - not required for performance reasons. 
* Remove limitation of iteration steps in util.clj, no longer required. 
* Unify the row- and column-creation functions in segment.clj. 
* Check if using pmap in the iteration part really speeds up computation

### Bugs

...

## License

Copyright Â© 2020 Werner Beckmann

This program and the accompanying materials are made available under the
terms of the Eclipse Public License 2.0 which is available at
http://www.eclipse.org/legal/epl-2.0.

This Source Code may also be made available under the following Secondary
Licenses when the conditions for such availability set forth in the Eclipse
Public License, v. 2.0 are satisfied: GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or (at your
option) any later version, with the GNU Classpath Exception which is available
at https://www.gnu.org/software/classpath/license.html.
